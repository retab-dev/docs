---
title: Webhooks
description: Receive workflow results via HTTP webhooks
---

## Overview

Retab uses HTTPS to send webhook events to your app as a JSON payload. When a workflow completes, the End (Webhook) node sends the processed data to your configured endpoint.

## Webhook Payload

The webhook sends a standardized JSON payload with the following structure:

| Field | Type | Description |
|-------|------|-------------|
| `document` | `MIMEData \| null` | Document data (if a file was passed to the End node) |
| `data` | `object \| null` | Extracted structured data (if JSON was passed to the End node) |

### MIMEData Structure

The `document` field uses the `MIMEData` format:

| Field | Type | Description |
|-------|------|-------------|
| `filename` | `string` | Original filename (e.g., `"invoice.pdf"`, `"scan.png"`) |
| `url` | `string` | Base64 data URL containing the file content |

The `url` field is a [data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) in the format:
```
data:<mime_type>;base64,<base64_encoded_content>
```

**Example Payload:**

```json
{
  "document": {
    "filename": "invoice.pdf",
    "url": "data:application/pdf;base64,JVBERi0xLjQKJeLjz9..."
  },
  "data": {
    "invoice_number": "INV-2024-001",
    "vendor_name": "Acme Corp",
    "total_amount": 1250.00,
    "line_items": [
      { "description": "Widget A", "quantity": 10, "unit_price": 100.00 },
      { "description": "Widget B", "quantity": 5, "unit_price": 50.00 }
    ]
  }
}
```

<Note>
Either `document` or `data` (or both) will be present depending on what's connected to the End node. If only an Extract node is connected, you'll receive `data` with the extracted data. If a document is also passed through, you'll receive both.
</Note>

### Parsing the Payload

<CodeGroup>
```python Python
from pydantic import BaseModel, Field
from typing import Any
import base64

class MIMEData(BaseModel):
    """Document data in base64 data URL format."""
    filename: str = Field(description="Original filename of the document")
    url: str = Field(description="Base64 data URL of the file content")
    
    @property
    def mime_type(self) -> str:
        """Extract MIME type from the data URL."""
        if self.url.startswith("data:"):
            return self.url.split(";")[0].split(":")[1]
        return "application/octet-stream"
    
    @property
    def content(self) -> bytes:
        """Decode the base64 content."""
        if self.url.startswith("data:"):
            base64_data = self.url.split(",")[1]
            return base64.b64decode(base64_data)
        raise ValueError("URL is not a data URL")

class WebhookPayload(BaseModel):
    document: MIMEData | None = None
    data: dict[str, Any] | None = Field(default=None)
```

```typescript Node.js
interface MIMEData {
    filename: string;
    url: string;
}

interface WebhookPayload {
    document: MIMEData | null;
    data: Record<string, any> | null;
}

// Helper to extract MIME type from data URL
function getMimeType(dataUrl: string): string {
    if (dataUrl.startsWith('data:')) {
        return dataUrl.split(';')[0].split(':')[1];
    }
    return 'application/octet-stream';
}

// Helper to decode base64 content
function getContent(dataUrl: string): Buffer {
    if (dataUrl.startsWith('data:')) {
        const base64Data = dataUrl.split(',')[1];
        return Buffer.from(base64Data, 'base64');
    }
    throw new Error('URL is not a data URL');
}
```
</CodeGroup>

## Setting Up Webhooks

To start receiving webhook events:

1. Create a webhook endpoint handler to receive POST requests
2. Configure the End node in your workflow with your webhook URL
3. Test your endpoint locally using the Retab SDK
4. Secure your webhook endpoint with signature verification

### Create a Webhook Endpoint Handler

Set up an HTTPS endpoint that:
- Handles POST requests with a JSON payload
- Returns a successful status code (2xx) quickly before complex processing
- Validates the webhook signature for security

<CodeGroup>
```python FastAPI (Python)
import base64
from fastapi import FastAPI, Request
from pydantic import BaseModel
from typing import Any

app = FastAPI()

class Invoice(BaseModel):
    invoice_number: str
    vendor_name: str
    total_amount: float

@app.post("/webhook")
async def webhook_handler(request: Request):
    payload = await request.json()
    
    # Extract the structured data
    data = payload.get("data")
    document = payload.get("document")
    
    if data:
        invoice = Invoice.model_validate(data)
        print(f"ðŸ“¬ Received invoice: {invoice.invoice_number} - ${invoice.total_amount}")
    
    if document:
        filename = document.get("filename")
        url = document.get("url", "")
        print(f"ðŸ“Ž Document: {filename}")
        
        # Optionally save the file
        if url.startswith("data:"):
            base64_content = url.split(",")[1]
            file_bytes = base64.b64decode(base64_content)
            with open(f"/tmp/{filename}", "wb") as f:
                f.write(file_bytes)
            print(f"   Saved to /tmp/{filename} ({len(file_bytes)} bytes)")
    
    return {"status": "success"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

```javascript Express (Node.js)
import express from 'express';
import fs from 'fs';

const app = express();
app.use(express.json({ limit: '50mb' })); // Increase limit for base64 files

app.post('/webhook', async (req, res) => {
    const { document, data } = req.body;
    
    if (data) {
        console.log(`ðŸ“¬ Received invoice: ${data.invoice_number} - $${data.total_amount}`);
    }
    
    if (document) {
        console.log(`ðŸ“Ž Document: ${document.filename}`);
        
        // Optionally save the file
        if (document.url.startsWith('data:')) {
            const base64Content = document.url.split(',')[1];
            const fileBuffer = Buffer.from(base64Content, 'base64');
            fs.writeFileSync(`/tmp/${document.filename}`, fileBuffer);
            console.log(`   Saved to /tmp/${document.filename} (${fileBuffer.length} bytes)`);
        }
    }
    
    res.status(200).json({ status: 'success' });
});

app.listen(8000, () => {
    console.log('Webhook server listening on port 8000');
});
```
</CodeGroup>

### Configure the End Node

In your workflow:

1. Add an **End** (Webhook) node
2. Connect your Extract or Functions node to the End node
3. Configure the webhook URL and any custom headers

```json
{
  "webhook_url": "https://api.yourapp.com/workflow-results",
  "webhook_headers": {
    "Authorization": "Bearer your-api-key",
    "X-Workflow-ID": "wf_abc123"
  }
}
```

### Test Your Webhook

Before deploying, test your webhook endpoint using the SDK:

<CodeGroup>
```python Python
from retab import Retab

client = Retab()

# Create a test processor and automation
processor = client.processors.create(
    name="Test Processor",
    model="gpt-4.1",
    json_schema=Invoice.model_json_schema(),
)

# Create an automation with your webhook
automation = client.processors.automations.links.create(
    name="Test Automation",
    processor_id=processor.id,
    webhook_url="https://your-server.com/webhook",
)

# Test with a document
result = client.processors.automations.links.test_document_upload(
    link_id=automation.id,
    document="test_invoice.pdf"
)

print(f"Test result: {result}")
```

```typescript Node.js
import Retab from 'retab';

const client = new Retab();

// Create a test processor and automation
const processor = await client.processors.create({
    name: 'Test Processor',
    model: 'gpt-4.1',
    json_schema: invoiceSchema,
});

const automation = await client.processors.automations.links.create({
    name: 'Test Automation',
    processor_id: processor.id,
    webhook_url: 'https://your-server.com/webhook',
});

// Test with a document
const result = await client.processors.automations.links.testDocumentUpload({
    link_id: automation.id,
    document: 'test_invoice.pdf'
});

console.log('Test result:', result);
```
</CodeGroup>

## Securing Your Webhook

<Warning>
An unsecured webhook endpoint is vulnerable to forged requests. Always verify the signature before processing webhook data.
</Warning>

### How Signature Verification Works

Retab uses HMAC-SHA256 to sign webhook payloads:

1. **Signature Generation**: Retab computes an HMAC-SHA256 signature of the payload using your webhook secret
2. **Signature Header**: The signature is included in the `Retab-Signature` header
3. **Verification**: Your server recomputes the signature and compares it to the header

If the signatures match, the request is authentic and unmodified.

### Getting Your Webhook Secret

You can create a webhook security key directly from the End node in the workflow editor:

1. Click the **key icon** (ðŸ”‘) in the End node header
2. Click **Create Security Key** if you don't have one
3. Copy the generated secret
4. Store it securely as an environment variable (e.g., `WEBHOOKS_SECRET`)

Alternatively, you can manage keys in your [Retab Dashboard](https://www.retab.com/dashboard/settings) under **Settings** â†’ **Security**.

### Implementation Examples

<CodeGroup>
```python FastAPI (Python)
import os
from fastapi import FastAPI, Request, Response, HTTPException
from retab import Retab

client = Retab()
app = FastAPI()

@app.post("/webhook")
async def webhook_handler(request: Request):
    payload = await request.body()
    signature_header = request.headers.get("Retab-Signature")

    if not signature_header:
        raise HTTPException(status_code=400, detail="Missing Retab-Signature header")

    try:
        # Verify the signature
        client.verify_event(
            event_body=payload,
            event_signature=signature_header,
            secret=os.getenv("WEBHOOKS_SECRET"),
        )
    except Exception as e:
        return Response(
            status_code=400, 
            content=f"Signature verification failed: {str(e)}"
        )

    # Signature verified - process the webhook
    import json
    data = json.loads(payload.decode('utf-8'))
    extracted_data = data.get("data")
    document = data.get("document")
    
    # Process your data...
    
    return Response(status_code=200)
```

```python Flask (Python)
import os
from flask import Flask, Response, request
from retab import Retab

client = Retab()
app = Flask(__name__)

@app.route("/webhook", methods=["POST"])
def webhook_handler():
    payload = request.get_data()
    signature_header = request.headers.get("Retab-Signature")

    if not signature_header:
        return Response("Missing Retab-Signature header", status=400)

    try:
        client.verify_event(
            event_body=payload,
            event_signature=signature_header,
            secret=os.getenv("WEBHOOKS_SECRET"),
        )
    except Exception as e:
        return Response(f"Signature verification failed: {str(e)}", status=400)

    # Process the webhook...
    import json
    data = json.loads(payload)
    # ...
    
    return Response(status=200)
```

```python Django (Python)
import os
import json
from django.http import HttpResponse, JsonResponse
from django.views.decorators.csrf import csrf_exempt
from retab import Retab

client = Retab()

@csrf_exempt
def webhook_handler(request):
    if request.method != "POST":
        return HttpResponse(status=405)
    
    payload = request.body
    signature_header = request.headers.get("Retab-Signature")

    if not signature_header:
        return JsonResponse({"error": "Missing Retab-Signature header"}, status=400)

    try:
        client.verify_event(
            event_body=payload,
            event_signature=signature_header,
            secret=os.getenv("WEBHOOKS_SECRET"),
        )
    except Exception as e:
        return HttpResponse(f"Signature verification failed: {str(e)}", status=400)

    # Process the webhook...
    data = json.loads(payload)
    # ...
    
    return HttpResponse(status=200)
```

```javascript Express (Node.js)
import express from 'express';
import Retab from 'retab';

const client = new Retab();
const app = express();

app.use(express.raw({ type: 'application/json' }));

app.post('/webhook', async (req, res) => {
    const payload = req.body;
    const signatureHeader = req.headers['retab-signature'];

    if (!signatureHeader) {
        return res.status(400).json({ detail: 'Missing Retab-Signature header' });
    }

    try {
        await client.verifyEvent({
            event_body: payload,
            event_signature: signatureHeader,
            secret: process.env.WEBHOOKS_SECRET,
        });
    } catch (error) {
        return res.status(400).send(`Signature verification failed: ${error.message}`);
    }

    // Process the webhook...
    const data = JSON.parse(payload.toString('utf-8'));
    const { document, data: extractedData } = data;
    
    console.log('Verified webhook:', { document, data: extractedData });
    
    return res.status(200).send();
});

app.listen(8000);
```

```javascript Fastify (Node.js)
import Fastify from 'fastify';
import Retab from 'retab';

const client = new Retab();
const fastify = Fastify();

// Enable raw body parsing
fastify.addContentTypeParser('application/json', { parseAs: 'buffer' }, (req, body, done) => {
    done(null, body);
});

fastify.post('/webhook', async (request, reply) => {
    const payload = request.body;
    const signatureHeader = request.headers['retab-signature'];

    if (!signatureHeader) {
        return reply.status(400).send({ detail: 'Missing Retab-Signature header' });
    }

    try {
        await client.verifyEvent({
            event_body: payload,
            event_signature: signatureHeader,
            secret: process.env.WEBHOOKS_SECRET,
        });
    } catch (error) {
        return reply.status(400).send(`Signature verification failed: ${error.message}`);
    }

    // Process the webhook...
    const data = JSON.parse(payload.toString('utf-8'));
    // ...
    
    return reply.status(200).send();
});

fastify.listen({ port: 8000 });
```

```javascript Next.js (Node.js)
import Retab from 'retab';

const client = new Retab();

export async function POST(request) {
    const payload = await request.arrayBuffer();
    const signatureHeader = request.headers.get('retab-signature');

    if (!signatureHeader) {
        return new Response(
            JSON.stringify({ detail: 'Missing Retab-Signature header' }),
            { status: 400, headers: { 'Content-Type': 'application/json' } }
        );
    }

    try {
        await client.verifyEvent({
            event_body: Buffer.from(payload),
            event_signature: signatureHeader,
            secret: process.env.WEBHOOKS_SECRET,
        });
    } catch (error) {
        return new Response(
            `Signature verification failed: ${error.message}`,
            { status: 400 }
        );
    }

    // Process the webhook...
    const data = JSON.parse(Buffer.from(payload).toString('utf-8'));
    const { document, data: extractedData } = data;
    
    console.log('Verified webhook:', { document, data: extractedData });

    return new Response(null, { status: 200 });
}
```
</CodeGroup>

## Security Best Practices

<AccordionGroup>
  <Accordion title="Always verify signatures">
    Never process webhook data without verifying the `Retab-Signature` header. This prevents attackers from sending forged requests to your endpoint.
  </Accordion>
  
  <Accordion title="Use HTTPS only">
    Always use HTTPS endpoints for webhooks. HTTP endpoints expose your webhook data to interception.
  </Accordion>
  
  <Accordion title="Respond quickly">
    Return a 2xx status code as soon as you receive and verify the webhook. Perform long-running processing asynchronously.
  </Accordion>
  
  <Accordion title="Handle retries">
    Retab may retry failed webhook deliveries. Implement idempotency to handle duplicate events gracefully.
  </Accordion>
  
  <Accordion title="Rotate secrets periodically">
    Regularly rotate your webhook secret to minimize the impact of potential secret exposure.
  </Accordion>
</AccordionGroup>

## Troubleshooting

### Common Issues

| Issue | Solution |
|-------|----------|
| **Missing signature header** | Ensure you're checking for `Retab-Signature` (case-insensitive) |
| **Signature mismatch** | Verify you're using the raw request body, not parsed JSON |
| **Timeout errors** | Return 200 immediately, process data asynchronously |
| **404 errors** | Check your webhook URL is accessible from the internet |

### Debugging Tips

1. **Log incoming requests**: Temporarily log the raw payload and headers to verify what you're receiving
2. **Test locally**: Use a tool like [ngrok](https://ngrok.com) to expose your local server for testing
3. **Check dashboard**: View webhook delivery logs in your Retab dashboard
4. **Verify secret**: Ensure your `WEBHOOKS_SECRET` matches the one in your dashboard
