Automations allow you to process documents at scale. 

## Introduction

Retab uses HTTPS to send webhook events to your app as a JSON payload representing a `WebhookRequest` object.
You will need a server with a webhook endpoint that will receive the extraction results, allowing you to process them as you want after that.


The `WebhookRequest` object is a Pydantic model that contains the following fields:

- `completion`: The parsed chat completion object, containing the extracted data.
- `user`: The user email address.
- `file_payload`: The file payload object, containing the file name, url and other metadata.
- `metadata`: Some additional metadata.


```python
from openai.types.chat.parsed_chat_completion import ParsedChatCompletion

class MIMEData(BaseModel):
    filename: str = Field(description="The filename of the file", examples=["file.pdf", "image.png", "data.txt"])
    url: str = Field(description="The URL of the file in base64 format", examples=["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIA..."])
    ##... other fields

class WebhookRequest(BaseModel):
    completion: ParsedChatCompletion
    user: Optional[EmailStr] = None
    file_payload: MIMEData
    metadata: Optional[dict[str, Any]] = None

```


To start receiving webhook events in your app:

- Create a webhook endpoint handler to receive event data POST requests.
- Create a new deployment sending data to your webhook endpoint.
- Test your webhook endpoint handler locally using the Retab SDK.
- Secure your webhook endpoint.


### Create a webhook endpoint handler

Set up an HTTPS endpoint function that can accept webhook requests with a POST method.

Set up your endpoint function so that it:

- Handles POST requests with a JSON payload consisting of an event object.
- Quickly returns a successful status code (2xx) prior to any complex logic that might cause a timeout.

```python
import os

from fastapi import FastAPI, Request, Response, HTTPException
from retab import Retab

reclient = Retab()
app = FastAPI()

@app.post("/webhook")
async def webhook_handler(request: Request):

    payload = await request.body()

    # Decode and parse the webhook request from the verified payload
    json_data = json.loads(payload.decode('utf-8'))
    webhook_request = WebhookRequest.model_validate(json_data)

    invoice_object = Invoice.model_validate_json(webhook_request.completion.choices[0].message.content or "{}") # The parsed object is the same Invoice object as the one you defined in the Pydantic model
    print("üì¨ Webhook received:", invoice_object)
    return {"status": "success", "data": invoice_object}


# To run the FastAPI app locally, use the command:
# uvicorn your_module_name:app --reload
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### Create a new deployment sending data to your webhook endpoint

Let's create a new processor and automation to send data to your webhook endpoint.

First, create a processor:

```python
class Invoice(BaseModel):
    amount: int
    currency: str
    customer_email: EmailStr


from retab import Retab

reclient = Retab()

# Step 1: Create a processor
processor = reclient.processors.create(
    name="Invoice Processor",
    model="gpt-4.1",
    json_schema=Invoice.model_json_schema(),
)

# Step 2: Create an automation and attach it to the processor
extraction_link = reclient.processors.automations.links.create(
    name="Invoices",
    processor_id=processor.id,
    webhook_url="https://your_server.com/invoices/webhook",
)
```

### Test your webhook endpoint handler locally using the Retab SDK

Before you go-live with your webhook endpoint function, we recommend that you test your application integration.

You can do so by sending a test request to your webhook endpoint using the Retab SDK.

```python
from retab import Retab

reclient = Retab()
link_log = reclient.processors.automations.links.test_document_upload(
    link_id=extraction_link.id,
    document = "invoice.pdf"
)
```

### Secure your webhook endpoint

You need to secure your integration by making sure your handler verifies that all webhook requests are generated by Retab. 

You perform the verification by providing the event payload, the `Retab-Signature` header, and the endpoint's secret. If verification fails, you get an error.


**Important:** Make sure to replace `"your_webhooks_secret_here"` with the actual secret from your [Retab dashboard](https://www.retab.dev/dashboard/settings).


```python {13-39}
import os

from fastapi import FastAPI, Request, Response, HTTPException
from retab import Retab

reclient = Retab()
app = FastAPI()

@app.post("/webhook")
async def webhook_handler(request: Request):

    payload = await request.body()

    #########################################################
    # SIGNATURE VERIFICATION
    #########################################################
    try:
        # Read the signature from the request headers
        
        signature_header = request.headers.get("Retab-Signature")

        if not signature_header:
            raise HTTPException(status_code=400, detail="Missing Retab-Signature header")

        # Verify the signature and process the event
        reclient.processors.automations.verify_event(
            event_body=payload,
            event_signature=signature_header,
            secret=os.getenv("WEBHOOKS_SECRET"),
        )

        return Response(status_code=200)
    except Exception as e:
        # Handle errors (optional: log the error)
        return Response(status_code=400, content=f"Webhook error: {str(e)}")

    ########################################################   
    # END OF SIGNATURE VERIFICATION
    #########################################################

    # Decode and parse the webhook request from the verified payload
    json_data = json.loads(payload.decode('utf-8'))
    webhook_request = WebhookRequest.model_validate(json_data)

    #Then continue with your webhook handler logic .....
    invoice_object = Invoice.model_validate_json(webhook_request.completion.choices[0].message.content or "{}") # The parsed object is the same Invoice object as the one you defined in the Pydantic model
    print("üì¨ Webhook received:", invoice_object)
    return {"status": "success", "data": invoice_object}


```

#### Vulnerability

When you set up a webhook, you provide an **HTTP endpoint** on your server for Retab to send data to. If this endpoint is not secured (i.e., it accepts unauthenticated `POST` requests from anywhere), it essentially becomes a public door into your system. **Any actor** could attempt to call this URL and send fake data. This is inherently dangerous: a malicious party might send **forged webhook requests** that masquerade as Retab, but contain bogus or harmful data. Without verification, your server might accept these fake events and perform unintended actions. In short, an open webhook endpoint without authentication is **highly vulnerable** to abuse.

#### Mitigation

To secure webhook deliveries, Retab employs a **signature verification** mechanism using an HMAC-like scheme (similar to the approach used by [Stripe](https://docs.stripe.com/webhooks#verify-official-libraries), [WorkOS](https://workos.com/docs/events/data-syncing/webhooks/1-set-up-your-webhook-endpoint), and other providers). HMAC stands for *Hash-Based Message Authentication Code*, a method that uses a secret key to create a cryptographic signature for each message. In fact, HMAC signing is by far the most popular strategy for webhook security (used in \~65% of webhook implementations), because it ensures that only the trusted source (with knowledge of the secret) could have sent the request.

**How it works:** Retab and your application share a **webhook secret** (a random string known only to Retab and you). This secret is available in your Retab dashboard (often labeled as `WEBHOOKS_SECRET`). Retab uses this secret to include a special signature header with every webhook request:

* **Signature Generation (Retab):** When Retab prepares to send a webhook, it computes an HMAC-SHA256 signature of the webhook's payload using your secret key, and includes this signature in the request headers (specifically in the `Retab-Signature` header).
* **Signature Verification (Your Server):** When your endpoint receives the webhook, your code should perform the same HMAC-SHA256 computation on the request body using the shared secret. Then, compare your computed signature to the value in the `Retab-Signature` header.
* **Comparison Result:** If the two signatures **match**, it means the request truly came from Retab (since only Retab knows the secret) and that the payload was not altered in transit. You can then safely trust and process the webhook. If the signatures **do not match**, the request is illegitimate ‚Äì either coming from an impostor or corrupted ‚Äì and you should reject it (e.g. respond with an HTTP 400 Bad Request or 401 Unauthorized).

By using this HMAC signature validation, we achieve both **authentication** and **integrity** for webhook messages: only the genuine sender (Retab) can produce a matching signature, and any change to the data would break the signature verification. In other words, a valid `Retab-Signature` proves that the webhook content is exactly what Retab sent and has not been tampered with.



#### Code Snippets
---
Here are some code snippets for different frameworks.

<CodeGroup>
```python FastAPI
import os

from fastapi import FastAPI, Request, Response, HTTPException
from retab import Retab

reclient = Retab()
app = FastAPI()

@app.post("/webhook")
async def webhook_handler(request: Request):
    try:
        # Read payload and signature from request
        payload = await request.body()
        signature_header = request.headers.get("Retab-Signature")

        if not signature_header:
            raise HTTPException(status_code=400, detail="Missing Retab-Signature header")

        # Verify the signature and process the event
        reclient.processors.automations.verify_event(
            event_body=payload,
            event_signature=signature_header,
            secret=os.getenv("WEBHOOKS_SECRET"),
        )

        return Response(status_code=200)
    except Exception as e:
        # Handle errors (optional: log the error)
        return Response(status_code=400, content=f"Webhook error: {str(e)}")
```
```python Django
import os

from django import Response
from retab import Retab

reclient = Retab()

def webhook_handler(request):
    payload = request.get_data()
    signature_header = request.headers["Retab-Signature"]

    # Verify the signature and process the event
    response = reclient.processors.automations.verify_event(
        event_body=payload,
        event_signature=signature_header,
        secret=os.getenv("WEBHOOKS_SECRET"),
    )

    return Response(status=200)
```
```python Flask
import os

from flask import Flask, Response, request
from retab import Retab

reclient = Retab()

app = Flask(__name__)


@app.route("/webhook", methods=["POST"])
def webhook_handler():
    payload = request.get_data()
    signature_header = request.headers["Retab-Signature"]

    # Verify the signature and process the event
    response = reclient.processors.automations.verify_event(
        event_body=payload,
        event_signature=signature_header,
        secret=os.getenv("WEBHOOKS_SECRET"),
    )

    return Response(status=200)
```
</CodeGroup>

## Create your processor

Start by creating a **processor** with your extraction configuration.

```python
from retab import Retab

client = Retab()

processor = client.processors.create(
    name="Invoice Processor",
    model="gpt-4.1",
    json_schema="Invoice_schema.json"
)

```

## Create your FastAPI server with a webhook

Then, set up a FastAPI route that will handle incoming webhook POST requests. You will need it to create an automation. Below is an example of a simple FastAPI application with a webhook endpoint:

<CodeGroup>
```python main.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from retab.types.automations.webhooks import WebhookRequest
from pydantic import BaseModel, Field, ConfigDict

app = FastAPI()

@app.post("/webhook")
async def webhook(request: WebhookRequest):
    invoice_object = json.loads(request.completion.choices[0].message.content or "{}") # The parsed object is the same Invoice object as the one you defined in the Pydantic model
    print("üì¨ Webhook received:", invoice_object)
    return {"status": "success", "data": invoice_object}

# To run the FastAPI app locally, use the command:
# uvicorn your_module_name:app --reload
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

You can test the webhook endpoint locally with a tool like curl or Postman. For example, using curl:

```bash testing locally
curl -X POST http://localhost:8000/webhook \
     -H "Content-Type: application/json" \
     -d '{"completion":{"id":"id","choices":[{"index":0,"message":{"content":"{\"name\" : \"Team Meeting!\", \"date\" : \"2023-12-31\" }","role":"assistant"}}],"created":0,"model":"gpt-4.1-nano","object":"chat.completion","likelihoods":{}},"file_payload":{"filename":"example.pdf","url":"data:application/pdf;base64,the_content_of_the_pdf_file"}}'
```
</CodeGroup>

<Warning>To continue, you need to deploy your FastAPI app to a server to make your webhook endpoint publicly accessible. We recommend using [Replit](https://replit.com/) to get started quickly if you don't have a server yet. An alternative is to use [ngrok](https://ngrok.com/) to expose your local server to the internet.</Warning>

## Exposing local server to the internet using ngrok

We have a very simple Dockerfile that fastapi+ngrok to get you started.
Check out the [webhook_server](https://github.com/Retab-dev/retab/tree/main/examples/webhook_server) folder for more details.

<Tip>You will need a ngrok auth token to run the docker container. You can get one [here](https://dashboard.ngrok.com/get-started)</Tip>

Start fastapi+ngrok server:

<CodeGroup>
```bash startup
git clone https://github.com/Retab-dev/retab.git
cd retab/examples/webhook_server
docker build -t webhook_server .
docker run --rm -it -e NGROK_AUTH_TOKEN=[your_ngrok_auth_token] webhook_server
```

```logs {4} server logs
INFO:     Started server process [1]
INFO:     Waiting for application startup.
üåç Ngrok tunnel established!
üì¨ Webhook URL: https://some-random-ngrok-url.ngrok-free.app/webhook
üì¨ Simple curl for testing: curl -X POST https://some-random-ngrok-url.ngrok-free.app/webhook -H "Content-Type: application/json" -d '{"completion":{"id":"id","choices":[{"index":0,"message":{"content":"{\"message\" : \"Hello, World!\"}","role":"assistant"}}],"created":0,"model":"gpt-4.1-nano","object":"chat.completion","likelihoods":{}},"file_payload":{"filename":"example.pdf","url":"data:application/pdf;base64,the_content_of_the_pdf_file"}}'
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
```
</CodeGroup>

Take note of the `webhook URL`, you will need it on the next steps.


## Create an automation

Now, you can create an automation that will use your processor to extract data from emails.

```python
from retab import Retab

client = Retab()

# Create a mailbox automation and attach it to the processor
mailbox = client.processors.automations.mailboxes.create(
    name="Invoice Mailbox",
    email="invoices@mailbox.retab.dev",
    processor_id=processor.id, # The processor id you created in the previous step
    webhook_url="https://your-server.com/webhook",  # Replace with your actual webhook URL
)
```

At any email sent to `invoices@mailbox.retab.dev`, the automation will use your processor configuration to extract data and send a POST request to your FastAPI webhook endpoint.

You can see the processor and automation you just created on your [dashboard](https://www.retab.dev/dashboard/processors)!

### Test your automation

Finally, you can test the processor and automation rapidly with the test functions of the SDK: 

```python
from retab import Retab

# Initialize the Retab client
client = Retab()

# If you just want to send a test request to your webhook
log = client.processors.automations.mailboxes.tests.webhook(
    email="invoices@mailbox.retab.dev", 
)

# If you want to test the file processing logic: 
log = client.processors.automations.mailboxes.tests.process(
    email="invoices@mailbox.retab.dev", 
    document="your_invoice_email.eml"
)

# If you want to test a full email forwarding
log = client.processors.automations.mailboxes.tests.forward(
    email="invoices@mailbox.retab.dev", 
    document="your_invoice_email.eml"
)
```

<Tip>You can also test your webhook locally by overriding the webhook url set in the automation</Tip>

You can also test your automation directly from the [dashboard](https://www.retab.dev/dashboard/processors).

```python
from retab import Retab

client = Retab()

# If you just want to send a test request to your webhook
log = client.processors.automations.mailboxes.tests.webhook(
    email="invoices@mailbox.retab.dev", 
    webhook_url="http://localhost:8000/webhook" # If you want to try your webhook locally, you can override the webhook url set in the automation
)
```




---


That's it! You can start processing documents at scale. 
