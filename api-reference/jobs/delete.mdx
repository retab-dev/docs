---
title: 'Cancel Job'
openapi: 'POST /v1/jobs/{job_id}/cancel'
---

<RequestExample>

```python python
from retab import Retab

client = Retab()

# Cancel a queued or in-progress job
cancelled_job = client.jobs.cancel("job_V1StGXR8_Z5jdHi6B-myT")

print(f"Status: {cancelled_job.status}")  # cancelled
```

```javascript javascript
import { Retab } from '@retab/node';

const client = new Retab();

// Cancel a queued or in-progress job
const cancelledJob = await client.jobs.cancel("job_V1StGXR8_Z5jdHi6B-myT");

console.log(`Status: ${cancelledJob.status}`);  // cancelled
```

```bash curl
curl -X POST \
  'https://api.retab.com/v1/jobs/job_V1StGXR8_Z5jdHi6B-myT/cancel' \
  -H "Api-Key: $RETAB_API_KEY"
```

</RequestExample>

<ResponseExample>

```json 200
{
  "id": "job_V1StGXR8_Z5jdHi6B-myT",
  "object": "job",
  "status": "cancelled",
  "endpoint": "/v1/documents/extract",
  "request": {
    "document": {
      "filename": "invoice.pdf",
      "url": "data:application/pdf;base64,..."
    },
    "json_schema": { ... },
    "model": "retab-small"
  },
  "response": null,
  "error": null,
  "created_at": 1705420800,
  "started_at": null,
  "completed_at": 1705420850,
  "expires_at": 1706025600,
  "organization_id": "org_abc123",
  "metadata": {"batch_id": "batch_001"}
}
```

```json 400
{
  "detail": "Cannot cancel job in 'completed' status"
}
```

```json 404
{
  "detail": "Job not found"
}
```

</ResponseExample>

## Path Parameters

<ParamField path="job_id" type="string" required>
  The unique identifier of the job to cancel.
</ParamField>

## Response Fields

<ResponseField name="id" type="string">
  Unique identifier for the job.
</ResponseField>

<ResponseField name="object" type="string">
  Always `"job"`.
</ResponseField>

<ResponseField name="status" type="string">
  Will be `"cancelled"` on success.
</ResponseField>

<ResponseField name="endpoint" type="string">
  The target endpoint for this job.
</ResponseField>

<ResponseField name="request" type="object">
  The original request body submitted.
</ResponseField>

<ResponseField name="response" type="null">
  Always null for cancelled jobs.
</ResponseField>

<ResponseField name="error" type="null">
  Always null for cancelled jobs.
</ResponseField>

<ResponseField name="created_at" type="integer">
  Unix timestamp when the job was created.
</ResponseField>

<ResponseField name="started_at" type="integer | null">
  Unix timestamp when processing started (if it had started).
</ResponseField>

<ResponseField name="completed_at" type="integer">
  Unix timestamp when the job was cancelled.
</ResponseField>

<ResponseField name="expires_at" type="integer">
  Unix timestamp when the job data will expire.
</ResponseField>

<ResponseField name="organization_id" type="string">
  The organization that owns this job.
</ResponseField>

<ResponseField name="metadata" type="object | null">
  User-provided metadata from job creation.
</ResponseField>

## Cancellation Behavior

The cancellation behavior depends on the job's current status:

| Current Status | Behavior |
|----------------|----------|
| `validating` | Immediately cancelled |
| `queued` | Removed from queue and cancelled |
| `in_progress` | Marked for cancellation; processing may complete if already finishing |
| `completed` | Returns 400 error - cannot cancel |
| `failed` | Returns 400 error - cannot cancel |
| `cancelled` | Returns 400 error - already cancelled |
| `expired` | Returns 400 error - cannot cancel |

<Note>
Jobs that are `in_progress` may still complete if the cancellation request arrives after processing has finished but before the status is updated. Always check the final status of the returned job object.
</Note>

## Use Cases

### Cancel a Batch of Jobs

<CodeGroup>
```python Python
# Cancel all queued jobs from a specific batch
jobs = client.jobs.list(status="queued")
for job in jobs.data:
    if job.metadata and job.metadata.get("batch_id") == "batch_001":
        try:
            client.jobs.cancel(job.id)
            print(f"Cancelled {job.id}")
        except Exception as e:
            print(f"Failed to cancel {job.id}: {e}")
```

```javascript JavaScript
// Cancel all queued jobs from a specific batch
const jobs = await client.jobs.list({ status: "queued" });
for (const job of jobs.data) {
    if (job.metadata?.batch_id === "batch_001") {
        try {
            await client.jobs.cancel(job.id);
            console.log(`Cancelled ${job.id}`);
        } catch (e) {
            console.log(`Failed to cancel ${job.id}:`, e);
        }
    }
}
```
</CodeGroup>

### Timeout-based Cancellation

<CodeGroup>
```python Python
import time

job = client.jobs.create(endpoint="/v1/documents/extract", request={...})
start_time = time.time()
timeout = 60  # 60 seconds

while job.status not in ("completed", "failed", "cancelled", "expired"):
    if time.time() - start_time > timeout:
        job = client.jobs.cancel(job.id)
        print("Job cancelled due to timeout")
        break
    time.sleep(2)
    job = client.jobs.retrieve(job.id)
```

```javascript JavaScript
const job = await client.jobs.create({ endpoint: "/v1/documents/extract", request: {...} });
const startTime = Date.now();
const timeout = 60000;  // 60 seconds

const terminalStatuses = ["completed", "failed", "cancelled", "expired"];
while (!terminalStatuses.includes(job.status)) {
    if (Date.now() - startTime > timeout) {
        const cancelledJob = await client.jobs.cancel(job.id);
        console.log("Job cancelled due to timeout");
        break;
    }
    await new Promise(r => setTimeout(r, 2000));
    job = await client.jobs.retrieve(job.id);
}
```
</CodeGroup>
